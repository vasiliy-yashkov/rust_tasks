use std::io::Write;
use std::str::FromStr;
extern crate num_cpus;

// Use #[path] declaration to set a path to the modules
#[path = "bounds.rs"]
mod bounds;
#[path = "math.rs"]
mod math;
#[path = "parsing.rs"]
mod parsing;
#[path = "render.rs"]
mod render;

fn main() {
    // Get arguments as a vector of strings
    let args: Vec<String> = std::env::args().collect();
    // If length of arguments vector is not 5, then print the error and
    // the help message
    if args.len() < 5 {
        writeln!(
            std::io::stderr(),
            "Help: mandelbrot_set <file> <pixels> <upper_left> <lower_right> [threads_number]"
        )
        .unwrap(); // Unwrap is used to check on errors when print in stderr
        writeln!(
            std::io::stderr(),
            "Example: {} output.png 1024x720 -1.20,0.35 -1,0.20",
            args[0]
        )
        .unwrap();
        std::process::exit(1);
    }

    // Get available processors count
    let mut threads_num: u32 = num_cpus::get() as u32;
    if args.len() == 6 {
        threads_num = u32::from_str(&args[5]).expect("Error parsing the number of threads");
    }

    // Try to parse size of image contained in 2 argument as a string with the 'x' character as a divisor
    let bounds = parsing::parse_pair(&args[2], 'x').expect("Error parsing the result image size");
    // Try to parse upper left and lower right complex point
    // contained in 3 and 4 arguments as a string contains
    // floating numbers with the ',' character as a divisor between two numbers
    let upper_left = parsing::parse_complex(&args[3])
        .expect("Error parsing the coordinates of the upper left corner");
    let lower_right = parsing::parse_complex(&args[4])
        .expect("error parsing the coordinates of the lower right corner");
    // The vec![v; n] macros calling creates a vector with n elements
    // initialized with v, so this code creates a vector of zeros of
    // length bounds.0 * bounds.1, where bounds is the image size
    // specified on the command argument. This vector will be used
    // as a rectangular array of byte halftone pixels.
    let mut pixels = vec![0; bounds.0 * bounds.1];
    // Here the render function is called, which computes the image.
    // The expression `&mut pixels` takes a mutable link to pixel buffer,
    // giving render the ability to fill it with calculated halftone
    // values, while pixels remain the owner of the vector.
    // The remaining arguments pass the image size and
    // the rectangle on the complex plane, which going to draw.
    // The lines number is rounded in excess so that stripes
    // cover the entire image, even if the height is not divide by `threads_num` completely.
    let rows_per_band: usize = bounds.1 as usize / threads_num as usize + 1; // Expcilit conversion for division
    {
        // The `chunks_mut` buffer method returns an iterator that generates mutable
        // non-overlapping portions of the buffer, each of which covers
        // the `rows_per_band * bounds.0` pixels, that is, the `rows_per_band` of
        // the full rows of pixels. The last span generated by the `chunks_mut`
        // method may contain fewer lines, but the number of pixels in all lines is the same.
        // Finally, the `collect` iterator method constructs a vector containing these sections.
        let bands: Vec<&mut [u8]> = pixels.chunks_mut(rows_per_band * bounds.0).collect();
        // The `| spawner | {...}` argument is an expression of closure in Rust.
        // A closure is something that can be called as a function. In this case,
        // `|spawner|` Is a list of arguments, and `{...}` is the body of the function.
        // In contrast to functions declared with by the power of the `fn` keyword,
        // there is no need to declare types of closure arguments, Rust itself
        // will output both them and the type of the return value.
        // Here, `crossbeam::scope` call the closure, passing as the `spawner`
        // argument a value that the closure can use to create new threads.
        // The `crossbeam::scope` function waits for all threads to complete
        // and then returns. With this behavior, Rust can guarantee that threads
        // will not access their portions of the pixels buffer after it leaves
        // the scope, and can be sure that after returning from`crossbeam::scope`
        // the image is fully computed.
        let res = crossbeam::scope(|spawner| {
            // Here we go around the pixel buffer stripes. The `into_iter()` iterator
            // makes each iteration of the loop the exclusive owner of one strip,
            // ensuring that only one thread can write to it at a time.
            for (i, band) in bands.into_iter().enumerate() {
                let top = rows_per_band * i;
                let height = band.len() / bounds.0;
                let band_bounds = (bounds.0, height);
                let band_upper_left =
                    bounds::pixel_to_point(bounds, (0, top), upper_left, lower_right);
                let band_lower_right = bounds::pixel_to_point(
                    bounds,
                    (bounds.0, top + height),
                    upper_left,
                    lower_right,
                );
                // Finally, create the thread that closes `move || {...}`. This is
                // the closure without arguments to the body "{...}". The keyword
                // `move` at the beginning says that this closure takes ownership
                // of the variables used in it; in particular, only a closure can
                // use the variable `band` section.
                spawner.spawn(move |_| {
                    render::render(band, band_bounds, band_upper_left, band_lower_right);
                });
            }
        });
        match res {
            Ok(f) => f,
            Err(e) => {
                eprintln!("Error {:?}", e);
                std::process::exit(1);
            }
        };
    }
    // Finally, output the pixel buffer to a .png file. In this case,
    // a shared (immutable) reference to the buffer is transmitted,
    // because the `write_image` function does not modify the contents of the buffer.
    render::write_image(&args[1], &pixels, bounds).expect("Error writing .png file");
}
